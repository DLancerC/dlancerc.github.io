<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[Maven 学习笔记（三）]]></title>
      <url>%2F2017%2F05%2F15%2FMaven%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-3%2F</url>
      <content type="text"><![CDATA[Maven中, 任何一个依赖,插件或者项目构建的输出, 被称为构件.利用坐标机制, Maven会使用一个统一位置来存储所有Maven项目共享的构建, 就是Maven仓库.对应一个构建在Maven仓库的路径一般为 groupId/artifactId/version/artifactId-version[-classifier].packaging Maven 仓库的分类 本地仓库 本机用户目录下的.m2/repository 可以通过修改配置文件(~/.m2/settings.xml)自定义本地仓库目录, 也可以修改全局配置文件($MAVEN_HOME/conf/settings.xml) 123&lt;settings&gt; &lt;localRepository&gt;customer Path &lt;/localRepository&gt;&lt;/settings&gt; 远程仓库 包括中央仓库和私服, 可以修改配文件或者POM文件添加远程仓库地址 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697 &lt;settings&gt; ... &lt;profiles&gt; &lt;profile&gt; &lt;!-- profile配置的唯一标识符 --&gt; &lt;id&gt;&lt;/id&gt; &lt;activation&gt; &lt;!--profile默认是否激活的标识 --&gt; &lt;activeByDefault&gt;false&lt;/activeByDefault&gt; &lt;!--检测jdk版本，与设置一样profile被激活。 --&gt; &lt;jdk&gt;1.7&lt;/jdk&gt; &lt;!--匹配的操作系统属性被检测到，profile被激活 --&gt; &lt;os&gt; &lt;!--激活profile的操作系统的名字 --&gt; &lt;name&gt;Windows XP&lt;/name&gt; &lt;!--激活profile的操作系统所属家族(如 'windows') --&gt; &lt;family&gt;Windows&lt;/family&gt; &lt;!--激活profile的操作系统体系结构 --&gt; &lt;arch&gt;x86&lt;/arch&gt; &lt;!--激活profile的操作系统版本 --&gt; &lt;version&gt;5.1.2600&lt;/version&gt; &lt;/os&gt; &lt;!--如果Maven检测到某一个属性（其值可以在POM中通过$&#123;名称&#125;引用），其拥有对应的名称和值，Profile就会被激活。--&gt; &lt;!--如果值字段是空的，那么存在属性名称字段就会激活profile，否则按区分大小写方式匹配属性值字段 --&gt; &lt;property&gt; &lt;!--激活profile的属性的名称 --&gt; &lt;name&gt;mavenVersion&lt;/name&gt; &lt;!--激活profile的属性的值 --&gt; &lt;value&gt;2.0.3&lt;/value&gt; &lt;/property&gt; &lt;!--提供一个文件名，通过检测该文件的存在或不存在来激活profile。--&gt; &lt;file&gt; &lt;!--如果指定的文件存在，则激活profile。 --&gt; &lt;exists&gt;/usr/local/hudson/hudson-home/jobs/maven-guide-zh-to-production/workspace/&lt;/exists&gt; &lt;!--如果指定的文件不存在，则激活profile。 --&gt; &lt;missing&gt;/usr/local/hudson/hudson-home/jobs/maven-guide-zh-to-production/workspace/&lt;/missing&gt; &lt;/file&gt; &lt;/activation&gt; &lt;!--对应profile的扩展属性列表。Maven属性和Ant中的属性一样，可以用来存放一些值。这些值可以在POM中的任何地方使用标记$&#123;X&#125;来使用，这里X是指属性的名称。--&gt; &lt;!--属性有五种不同的形式，并且都能在settings.xml文件中访问。 --&gt; &lt;!--1. env.X: 在一个变量前加上"env."的前缀，会返回一个shell环境变量。例如,"env.PATH"指代了$path环境变量（在Windows上是%PATH%）。 --&gt; &lt;!--2. project.x：指代了POM中对应的元素值。 --&gt; &lt;!--3. settings.x: 指代了settings.xml中对应元素的值。 --&gt; &lt;!--4. Java System Properties: 所有可通过java.lang.System.getProperties()访问的属性都能在POM中使用该形式访问， --&gt; &lt;!-- 如/usr/lib/jvm/java-1.6.0-openjdk-1.6.0.0/jre。 --&gt; &lt;!--5. x: 在&lt;properties/&gt;元素中，或者外部文件中设置，以$&#123;someVar&#125;的形式使用。 --&gt; &lt;properties&gt; &lt;!-- 这个profile被激活，则属性$&#123;user.install&#125;就可以被访问了 --&gt; &lt;user.install&gt;&lt;/user.install&gt; &lt;/properties&gt; &lt;!-- POM文件修改在 project 标签内添加 --&gt; &lt;repositories&gt; &lt;repository&gt; &lt;!-- 仓库ID, 唯一的, Maven自带的中央仓库使用的ID是central, 如果添加的其它仓库也使用了该ID, 会覆盖 --&gt; &lt;id&gt;&lt;/id&gt; &lt;name&gt;&lt;/name&gt; &lt;url&gt;&lt;/url&gt; &lt;!-- 是否支持发布版本下载 --&gt; &lt;releases&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;!-- 配置更新频率, 默认daily, 每天检查一次. never 从不检查更新 always 每次构建时检查更新 interval: X 每隔X分钟检查更新 --&gt; &lt;updatePolicy&gt;&lt;/updatePolicy&gt; &lt;!-- 配置检查检验和文件策略, 构建时下载构件出现校验和验证的失败, 默认为warn, 会输出警告信息 fail Maven遇到校验和验证的失败, 让构建失败 ignore Maven完全忽略校验和验证的失败错误 --&gt; &lt;checksumPolicy&gt;&lt;/checksumPolicy&gt; &lt;/releases&gt; &lt;!-- 是否支持快照版本下载 --&gt; &lt;snapshots&gt; &lt;enabled&gt;false&lt;/enabled&gt; &lt;/snapshots&gt; &lt;layout&gt;default&lt;/layout&gt; &lt;/repository&gt; &lt;!-- 可以添加多个地址 --&gt; &lt;repository&gt; ... &lt;/repository&gt; &lt;/repositories&gt; &lt;/profile&gt; &lt;/profiles&gt; &lt;servers&gt; &lt;server&gt; &lt;!-- 对应Repository的ID --&gt; &lt;id&gt;&lt;id&gt; &lt;username&gt;&lt;/username&gt; &lt;password&gt;&lt;/password&gt; &lt;/server&gt; &lt;/servers&gt; ...&lt;/settings&gt; 部署至远程仓库私服可以部署第三方构件, 可以通过配置POM文件或者部署命令将项目生成的构件部署到仓库中. 12345678910111213141516&lt;project&gt; ... &lt;distributionManagement&gt; &lt;repositroy&gt; &lt;id&gt;Release Repository ID&lt;/id&gt; &lt;name&gt;Release Repository Name&lt;/name&gt; &lt;url&gt;deploy URL&lt;/url&gt; &lt;/repositroy&gt; &lt;snapshotRepository&gt; &lt;id&gt;Snapshot Repository ID&lt;/id&gt; &lt;name&gt;Snapshot Repository Name&lt;/name&gt; &lt;url&gt;deploy URL&lt;/url&gt; &lt;/snapshotRepository&gt; &lt;/distributionManagement&gt; ...&lt;/project&gt; 配置完后, 命令运行mvn clean deploy即可.如果不配置POM, 则使用: 1234mvn clean deploy -U -Dmaven.test.skip=true -DaltDeploymentRepository=id::layout::url # id: 对 应 setting 中&lt;servers&gt;标签里配置的 Repository ID# layout: Either default for the Maven2 layout or legacy for the Maven1 layout. Maven3 also uses the default layout.# url: The location of the repository 部署或者是下载构件到远程仓库, 当需要认证时, 配置方式都是一致的. 快照版本在快照发布到私服时, Maven 会自动为构件打上时间戳, 当构建最新项目时, Maven会从仓库中检查对应快照版本的默认的最新构件, 发现有更新时会下载. 默认情况下(未修改snapshots下的updatePolicy), Maven 会每天检查一次更新, 构建时可以使用 -U 强制检查更新. 1mvn clean install -e -U -Dmaven.skip=true 从仓库解析依赖的机制 当依赖范围是 system 的时候, Maven 直接从本地文件系统解析构件. 根据依赖坐标计算仓库路径, 尝试直接从本地仓库寻找构件, 如果发现相应构件, 则解析成功. 在本地仓库不存在相应构件的情况下, 如果依赖的版本是显示的发布版本构件, 如 1.1, 2.3 等, 则遍历所有远程仓库, 发现后, 下载并解析使用. 如果依赖的版本是 RELEASE 或者 LATEST, 则基于更新策略读取所有远程仓库的元数据 groupId/artifactId/version/maven-metadata.xml, 将其与本地仓库的对应元数据合并后, 计算出 RELEASE 的真实值, 然后基于这个真实值检查本地和远程仓库 如果依赖的版本是 SNAPSHOT, 则基于更新策略读取所有远程仓库的与则基于更新策略读取所有远程仓库的元数据 groupId/artifactId/version/maven-metadata.xml, 将其与本地仓库的对应元数据合并后, 计算出快照的最新版本, 然后基于这个真实值检查本地和远程仓库. 如果最后解析得到的构件是时间格式的快照, 会将其复制为非时间戳的格式, 并会使用该构件. △: 依赖和声明中不推荐使用 LATEST 和 RELEASE, 由于 Maven 构件的解析机制可能会不同时间的构件会解析到不同版本的构件. 镜像如果仓库 A 可以提供 仓库 B 的所有的内容, 则 A 是 B 仓库的镜像. 则任何从 B 仓库获取的构件, A 也可获取. 可以通过修改setting.xml使用镜像. 1234567891011121314151617181920212223&lt;settings&gt; ... &lt;mirrors&gt; &lt;mirror&gt; &lt;!-- 该镜像的唯一标识 --&gt; &lt;id&gt;&lt;/id&gt; &lt;name&gt;&lt;/name&gt; &lt;url&gt;&lt;/url&gt; &lt;!-- 值对应一般仓库的Id,*(所有) --&gt; &lt;mirrorOf&gt;&lt;/mirrorOf&gt; &lt;!-- 通配例子 --&gt; &lt;!-- 匹配所有远程仓库 --&gt; &lt;mirrorOf&gt;*&lt;/mirrorOf&gt; &lt;!-- 匹配所有不在本机上的远程仓库, 如localhost, file:// --&gt; &lt;mirrorOf&gt;external: *&lt;/mirrorOf&gt; &lt;!-- 匹配仓库 repo1, repo2. 多个仓库用 , 分开 --&gt; &lt;mirrorOf&gt;repo1, repo2&lt;/mirrorOf&gt; &lt;!-- 匹配所有仓库, 除了仓库 repo1 --&gt; &lt;mirrorOf&gt;*, !repo1&lt;/mirrorOf&gt; &lt;/mirror&gt; &lt;/mirrors&gt; ...&lt;/settings&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Java 项目部署（一）]]></title>
      <url>%2F2017%2F04%2F11%2F%E7%B3%BB%E7%BB%9F%E9%83%A8%E7%BD%B2-1%2F</url>
      <content type="text"><![CDATA[上周六折腾了一天终于把快一年前的坑给填上了。阿里是越来越会玩了，ECS的价格从原来的40一个月慢慢的涨到了80。发现了腾讯服务器特惠，免费一个月加几张优惠劵，够半年了。把自己开发的一个轻博客部署上去了，这个博客整体样式仿照 Tumblr。注册的时候连接Outlook邮箱发注册邮件老是抽风，有时候邮件可以发成功有时候连接失败，下次有时间注册个邮件平台。 打算系统的记录下项目部署的过程和其中的遇到的的坑。 系统采用的是 Apache Https + Tomcat + MySql，采用的是企鹅家的云服务器，系统是 Centos，只开放了 80 端口供网页访问。 最后附上网站的链接。 Honks]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Java Puzzler（5-6）]]></title>
      <url>%2F2017%2F03%2F26%2FJavaPuzzler-2%2F</url>
      <content type="text"><![CDATA[5. 十六进制和八进制12345678910111213System.out.println(0x80);//128//0x81看作是int型，最高位(第32位)为0，所以是正数System.out.println(0x81);//129System.out.println(0x8001);//32769System.out.println(0x70000001);//1879048193//字面量0x80000001为int型，最高位(第32位)为1，所以是负数System.out.println(0x80000001);//-2147483647//字面量0x80000001L强制转为long型，最高位（第64位）为0，所以是正数System.out.println(0x80000001L);//2147483649//最小int型System.out.println(0x80000000);//-2147483648//只要超过32位，就需要在字面常量后加L强转long，否则编译时出错System.out.println(0x8000000000000000L);//-9223372036854775808 △ 如果Hex和Octal转换为10进制时字面常量的最高位为1，这个数为负数 十六进制的字面常量表示的是int型，如果超过32位，则需要在后面加“L”，否则编译过不过。如果为32，则为负int正数，超过32位，则为long型，但需明确指定为long。 通常最好避免混合类型运算 6. 多重转型（二进制原理） Type Bit Length Int 32位 2^31-1 byte 8位 2^7-1 char 16位 2^16-1 数据类型都要保留最高位作为符号位 有符号的数据类型存储是先将其无符号数Binary，在将其到最高位都置1如： 1234System.out.println(Integer.toBinaryString(-1));//1111 1111 1111 1111 1111 1111 1111 1111System.out.println(Integer.toBinaryString(-100));//1111 1111 1111 1111 1111 1111 1001 1100 符号扩展进行符号扩展，即短数据类型的符号位填充到长数据类型的高字节位（即比短数据类型多出的那一部分），保证扩展后的数值大小不变 123byte x=-1; int y=x; //则x的二进制值为1111 1111，y的值应为1111 1111 1111 1111 1111 1111 1000 1001；byte =1; short y=x; //则y的值应为0000 0000 0000 0000 0000 0000 0000 0001； 零扩展进行零扩展，即用零来填充长数据类型的高字节位 12unsigned char x=1000 1001b; short y=x; //则y的值应为00000000 10001001b；unsigned char x=0000 1001b; short y=x; //则y的值应为00000000 00001001b； △ 从较窄整型转换成较宽整型规定：如果最初的数值类型是有符号的，就进行符号扩展；如果它是char，那么不管它转化成什么类型，都是进行零扩展 12345678char c = (char)(0xff &amp; b);/* 0000 0000 0000 0000 0000 0000 1111 1111 (0Xff) &amp; 1111 1111 1111 1111 1111 1111 1001 1100 (b=-100) ----------------------------------------- 0000 0000 0000 0000 0000 0000 1001 1100 (100)*///0xff是第八位全部置1；其他位全部置0；//上面是不进行符号扩展]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Maven 学习笔记（二）]]></title>
      <url>%2F2017%2F03%2F11%2FMaven%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-2%2F</url>
      <content type="text"><![CDATA[Maven Dependency，Maven 除了快速构建项目外，还有一大功能就是管理项目依赖。Maven 的依赖管理通过groupId、artifactId、version等标识确定一个依赖的坐标，从而通过 Maven 仓库或获取对应的项目依赖的 Jar，自动化的解析任何一个 Java 构件。 Maven 坐标 groupId: 定义当前Maven项目隶属的实际项目. artifactId: 定义实际项目中的一个Maven项目(模块). version: 定义maven项目当前所处的版本. packaging: 定义Maven项目的打包方式. classifier: 定义构建输出的一些附属构件. 例如:一个项目的主构件是xxx-xxx-7.0.0.jar, 可能还需要javadoc和source, 这时javadoc和source就是附属构件的classifier, classifier不能定义, 它不是默认生成的, 而是由附加插件帮助生成的. groupId, artifactId, version是必须的, packaging 是可选的(默认jar), 而classifier是不能自定义的. maven项目生成的文件名一般为 artifactId-version[-classifier].packaging 依赖 POM 定义123456789101112131415161718192021222324&lt;project&gt;... &lt;!-- 项目所有的依赖--&gt; &lt;dependencies&gt; &lt;!-- 定义一个模块使用的一个依赖--&gt; &lt;dependency&gt; &lt;!-- 依赖的基本坐标--&gt; &lt;groupId&gt;&lt;/groupId&gt; &lt;artifactId&gt;&lt;artifactId&gt; &lt;version&gt;&lt;/version&gt; &lt;!-- 依赖类型,对应项目目标定义中的packaging, 不声明默认为Jar --&gt; &lt;type&gt;&lt;/type&gt; &lt;!-- 依赖作用范围--&gt; &lt;scope&gt;&lt;/scope&gt; &lt;!-- 标记依赖是否可选--&gt; &lt;optional&gt;&lt;/optional&gt; &lt;!-- 需要排除的依赖 --&gt; &lt;exclusions&gt; &lt;exclusion&gt;&lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;/dependencies&gt;...&lt;/project&gt; 依赖范围ScopeMaven会使用3种classpath来控制使用的依赖(编译classpath, 测试classpath, 运行测试classpath).Maven有以下几种依赖范围. compile 编译依赖范围. 默认依赖范围, 对应编译, 测试, 运行三种classpath都有效. eg: Spring-core test 测试依赖范围. 只对测试classpath有效, 在编译主代码或者运行项目中无法使用该依赖. eg: JUint provided 已提供的依赖范围. 对于编译和测试时有效, 运行时无效使用. eg: servlet-api runtime 运行时依赖范围. 对应测试和运行时有效, 但项目编译时无效. eg: JDBC ,编译时使用JDK提供的JDBC接口. system 系统依赖范围. 依赖范围和provided完全一致, 但是需要显示的指定依赖文件路径. 此类不是由Maven仓库解析处理,往往与本机系统绑定 1234567&lt;dependency&gt; &lt;groupId&gt;&lt;/groupId&gt; &lt;artifactId&gt;&lt;artifactId&gt; &lt;version&gt;&lt;/version&gt; &lt;scope&gt;system&lt;/scope&gt; &lt;systemPath&gt;$&#123;java.home&#125;/lib/rt.jar&lt;/systemPath&gt;&lt;/dependency&gt; import 导入依赖范围. 该依赖不会对classpath产生实际影响. Scope compile classpath test classpath runtime classpath compile Y Y Y test - Y - provided - Y Y runtime - Y Y system Y Y - 依赖传递依赖范围不但可以控制3种classpath的依赖,对传递性依赖也会产生影响. compile test provided runtime compile compile - - runtime test test - - test provided provided - provided provided runtime runtime - - runtime eg: Honks Test (Scope:Test, 对应表中行,第一依赖) 依赖Spring-email(Scope:compile, 对应表中列,第二依赖), Spring-email依赖java-mail. 则Honks Test通过传递依赖java-mail 依赖调解 依赖路径最近者优先 依赖路径相同, 先声明的优先 eg: A -&gt; B -&gt; C -&gt; X(1.0), A -&gt; B -&gt; X(2.0), 优先使用 X(2.0) [路径更短] A -&gt; B -&gt; X(1.0), A -&gt; B -&gt; X(2.0), 优先使用 X(1.0) [先声明] 依赖定义优化 定义优化 12345678910111213141516171819202122232425262728293031&lt;project&gt; &lt;modleVersion&gt;4.0.0&lt;/modleVersion&gt; &lt;groupId&gt;com.dlc.maven&lt;/groupId&gt; &lt;artifactId&gt;maven&lt;/artifactId&gt; &lt;version&gt;1.0.0&lt;/version&gt; &lt;!-- 依赖归类 --&gt; &lt;properties&gt; &lt;springframework.version&gt;3.6&lt;/springframework.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;!-- 使用依赖归类 --&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;version&gt;$&#123;springframework.version&#125;&lt;/version&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;maven-dep&lt;/artifactId&gt; &lt;version&gt;$&#123;springframework.version&#125;&lt;/version&gt; &lt;groupId&gt;com.dlc.maven&lt;/groupId&gt; &lt;artifactId&gt;maven-dep&lt;/artifactId&gt; &lt;version&gt;1.0.0&lt;/version&gt; &lt;!-- 依赖排除 --&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;com.dlc.maven&lt;/groupId&gt; &lt;artifactId&gt;maven-dep-dep&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/project&gt; 依赖优化 12345678# 查看当前项目的已解析依赖mvn dependency:list# 查看当前项目的依赖树mvn dependency:tree# 分析当前项目依赖mvn dependency:analyze# 输出 Used undeclared dependencies, 项目中使用的但没有显式声明的依赖(但当前项目依赖的传递性依赖中存在)# 输出 Unused declared dependencies, 项目未使用的, 当显式声明的依赖]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Java Annotation]]></title>
      <url>%2F2017%2F02%2F27%2FJava_Annotation%2F</url>
      <content type="text"><![CDATA[Java Annotation是JDK5.0引入的一种注释机制。随着 Spring 引入了大量的注释类，相比 XML 配置，注释配置更受欢迎，有进一步流行的趋势。可以通过 自定义一些注释来很大程度上减少代码。深入学习注解，就必须能定义自己的注解，并使用注解，在定义自己的注解之前，就必须要了解Java提供的元注解和相关定义注解的语法。 定义 Annotaiion需要声明为@interface @Target规定注释一定要写在什么语句上面@Target(ElementType.对应类型) 12345678910111213TYPE: 类,接口或者Enum声明FIELD: 域(属性)声明METHOD: 方法声明PARAMETER: 参数申明CONSTRUCTOR: 构造方法声明LOCAL_VARIABLE: 局部变量声明ANNOTATION_TYPE: 注释类声明PACKAGE: 包声明Java 8 之前的版本中，只能允许在声明式前使用 Annotation(Annotaion可以在任何使用Type的地方)TYPE_PARAMETER: Type 的声明式前TYPE_USE: 所有使用 Type 的地方(如：泛型，类型转换等) @Retention 需要在什么级别保存该注释信息@Retention(RetentionPolicy.对应类型) SOURCE: 注释将被编译器丢弃,例如@Override,这种只起到标示的注释 CLASS: 注释在class中,但是会被VM丢弃 RUNTIME: 注释在class中,VM中也会存在 @Documented 将此注解包含在Javadoc中 使用注释12345678910@Target(ElementType.METHOD)@Retention(RetentionPolicy.RUNTIME)@Documentedpublic @interface ValueBind &#123; enum fieldType&#123; STRING,INT &#125; fieldType type(); String value();&#125; 使用的Bean对象123456789101112131415161718192021222324252627282930313233public class Student implements Serializable &#123; private String studentId; private int age; private String name; public String getStudentId() &#123; return studentId; &#125; @ValueBind(type = ValueBind.fieldType.STRING,value = "7777") public void setStudentId(String studentId) &#123; this.studentId = studentId; &#125; public int getAge() &#123; return age; &#125; @ValueBind(type = ValueBind.fieldType.INT,value = "21") public void setAge(int age) &#123; this.age = age; &#125; public String getName() &#123; return name; &#125; @ValueBind(type = ValueBind.fieldType.STRING,value = "wuyu") public void setName(String name) &#123; this.name = name; &#125;&#125; 测试12345678910111213141516171819202122232425262728 public static void main(String[] args) throws Exception &#123; Object c = Class.forName("Student").newInstance(); /** * getMethod*() 获取的是类的public method * including those declared by the class(自己) or interface(接口) and those inherited from superclasses and superinterfaces(父类,父接口) * getDeclaredMethod*() 只得到自身申明的所有方法, * 包括public, protected, default (package) access, and private methods, but excluding inherited methods * * 对应没有method返回一个length=0 Array */ Method[] methodArray = c.getClass().getDeclaredMethods(); for (Method method: methodArray) &#123; if(method.isAnnotationPresent(ValueBind.class))&#123; ValueBind annotation = method.getAnnotation(ValueBind.class); String type = String.valueOf(annotation.type()); String value = annotation.value(); if("INT".equals(type))&#123; method.invoke(c,new Integer(value)); &#125;else&#123; method.invoke(c,value); &#125; &#125; &#125; AnnotationDemo1 annotationStudent = (AnnotationDemo1) c; System.out.println("StudentId===="+annotationStudent.getStudentId()); System.out.println("StudentName===="+annotationStudent.getName()); System.out.println("StudentAge===="+annotationStudent.getAge());&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Java Puzzler（1-4）]]></title>
      <url>%2F2017%2F02%2F11%2FJavaPuzzler-1%2F</url>
      <content type="text"><![CDATA[1. 奇数性123public static boolen isOdd(int i)&#123; return i %2 ==1;&#125; 上面的method是错误的，会在1/4的时间里返回的是错误值 a % b = c中c的值取决于a；只要a为正，无论b取何值，若有余数，c一定为正，同理可知a为负，c一定为负值。correct method：123456public static boolen idOdd(int i)&#123; rutrun i%2 != 0;&#125;punlic static boolen idOdd(int i)&#123; retrun (i&amp;1)!=0;&#125; 2. 找零时刻12345public class change&#123; punlic static void main (String[] args)&#123; System.out.println(2.00-1.10); &#125;&#125; 以上不会输出 0.9，而是0.899999999999使用printf（&quot;%.2f%n&quot;2.00-1.00);但是使用的double。△ Double是在一个很广的值域上提供一个很好的相识值，并不是精确值。在需要精确答案是，建议是要避免是用float和double，对于货币计算，建议使用int和long，Bigdecimal一定要使用Bigdecimal（String）构造器，千万不要使用BIgdecimal（double），返回仍会是不精确的值。 3. 长整除1234567public class LongDivsion&#123; public static void main(String[] args)&#123; final long a=24*60*60*1000*1000; final long b=24*60*60*1000; System.out.println(a/b); &#125;&#125; 以上返回不会输出1000，而是5。因为24*60*60*1000*1000会溢出，它并不是一个Long型，而是先算出结果后在转换成Long型的a。 1234567public class LongDivsion&#123; public static void main(String[] args)&#123; final long a=24L*60*60*1000*1000; final long b=24L*60*60*1000; System.out.println(a/b); &#125;&#125; △当操作很大的数时一定要提防溢出 4. 弱智问题（还是被骗了）12345public class Elementary&#123; public static void main(String[] args)&#123; System.out.println(1234567l); &#125;&#125; 注意1234567l，是l不是1…..△在使用long类型字面常量中，一定要用大写的L，千万不要用小写的l 同理，要避免使用单个l字母的变量名]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Maven 学习笔记（一）]]></title>
      <url>%2F2017%2F01%2F31%2FMaven%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1%2F</url>
      <content type="text"><![CDATA[做的项目大部分都是用 Maven 构建的，一直没有系统的学习和整理 Maven 的知识。最近接手的一个项目，研究架构代码的时候，发现一个大牛们写的一个通过解析 PDM 生成对应数据的生成实体对象的一个 Maven 插件。研究的时候发现很多 Maven 知识还不甚了解，找了本 《Maven 实战》系统的学习和整理知识点一遍。 Maven IntroduceMaven 是一种构建工具,同时还是一个依赖管理工具和项目信息管理工具.它提供了中央仓库,能帮我们自动下载构件. Maven 文件目录 bin 该目录包含mvn运行的脚本,这些脚本用来配置Java命令,mvnDebug,主要是 Maven 运行时开启debug,调试 Maven 本身. m2.conf文件, classworlds的配置文件. boot 只有一个文件,plexus-classworlds-(version).jar. 一个类加载器. Maven使用它加载对应自己的类库 conf settings.xml, 全局定义Maven行为. lib Maven运行所需的Java类库. 存放的真正的Maven, 里面内置了很多Maven的超级POM. 设置HTTP代理12345678910111213141516171819&lt;settings&gt;&lt;proxies&gt; &lt;proxy&gt; &lt;id&gt;my-proxy&lt;/id&gt; &lt;!-- 是否激活该代理 --&gt; &lt;active&gt; false | true &lt;/active&gt; &lt;!-- 代理协议 --&gt; &lt;protocol&gt;http&lt;/protocol&gt; &lt;host&gt;&lt;/host&gt; &lt;port&gt;&lt;/port&gt; &lt;!-- &lt;username&gt;***&lt;/username&gt; &lt;password&gt;***&lt;/password&gt; 设置不需要代理的主机名, * 表示所有以google.com的域名不使用代理 &lt;nonProxyHosts&gt;*.google.com&lt;/nonProxxyHosts&gt; --&gt; &lt;/proxy&gt;&lt;proxies&gt;&lt;/settings&gt; Maven ABC 编写POM 12345678910111213&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;!-- 指定当前POM版本,Maven2 以及Maven3 默认为 4.0.0 --&gt; &lt;modelVersion&gt;4.0.0&lt;/modleVersion&gt; &lt;!-- groupId+artifaceId定义一个项目的基本坐标--&gt; &lt;groupId&gt;&lt;/groupId&gt; &lt;!-- 当前所属group中的Maven的唯一ID--&gt; &lt;artifactId&gt;&lt;artifactId&gt; &lt;!-- artifast项目的版本号 --&gt; &lt;version&gt;&lt;/version&gt; &lt;!-- --&gt; &lt;name&gt;&lt;/name&gt;&lt;/project&gt; 编写主代码主代码位于 src/main/java, Java类的包名需要跟POM中定义的groupId和artifactId相吻合,编译输出为target 编写测试代码测试代码位于 src/test/java Archetype生成项目骨架1mvn archetype:generate]]></content>
    </entry>

    
  
  
</search>
