<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[Java 项目部署（一）]]></title>
      <url>%2F2017%2F04%2F11%2F%E7%B3%BB%E7%BB%9F%E9%83%A8%E7%BD%B2-1%2F</url>
      <content type="text"><![CDATA[上周六折腾了一天终于把快一年前的坑给填上了。阿里是越来越会玩了，ECS的价格从原来的40一个月慢慢的涨到了80。发现了腾讯服务器特惠，免费一个月加几张优惠劵，够半年了。把自己开发的一个轻博客部署上去了，这个博客整体样式仿照 Tumblr。注册的时候连接Outlook邮箱发注册邮件老是抽风，有时候邮件可以发成功有时候连接失败，下次有时间注册个邮件平台。 打算系统的记录下项目部署的过程和其中的遇到的的坑。 系统采用的是 Apache Https + Tomcat + MySql，采用的是企鹅家的云服务器，系统是 Centos，只开放了 80 端口供网页访问。 最后附上网站的链接。 Honks]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Java Puzzler（5-6）]]></title>
      <url>%2F2017%2F03%2F26%2FJavaPuzzler-2%2F</url>
      <content type="text"><![CDATA[5. 十六进制和八进制12345678910111213System.out.println(0x80);//128//0x81看作是int型，最高位(第32位)为0，所以是正数System.out.println(0x81);//129System.out.println(0x8001);//32769System.out.println(0x70000001);//1879048193//字面量0x80000001为int型，最高位(第32位)为1，所以是负数System.out.println(0x80000001);//-2147483647//字面量0x80000001L强制转为long型，最高位（第64位）为0，所以是正数System.out.println(0x80000001L);//2147483649//最小int型System.out.println(0x80000000);//-2147483648//只要超过32位，就需要在字面常量后加L强转long，否则编译时出错System.out.println(0x8000000000000000L);//-9223372036854775808 △ 如果Hex和Octal转换为10进制时字面常量的最高位为1，这个数为负数 十六进制的字面常量表示的是int型，如果超过32位，则需要在后面加“L”，否则编译过不过。如果为32，则为负int正数，超过32位，则为long型，但需明确指定为long。 通常最好避免混合类型运算 6. 多重转型（二进制原理） Type Bit Length Int 32位 2^31-1 byte 8位 2^7-1 char 16位 2^16-1 数据类型都要保留最高位作为符号位 有符号的数据类型存储是先将其无符号数Binary，在将其到最高位都置1如： 1234System.out.println(Integer.toBinaryString(-1));//1111 1111 1111 1111 1111 1111 1111 1111System.out.println(Integer.toBinaryString(-100));//1111 1111 1111 1111 1111 1111 1001 1100 符号扩展进行符号扩展，即短数据类型的符号位填充到长数据类型的高字节位（即比短数据类型多出的那一部分），保证扩展后的数值大小不变 123byte x=-1; int y=x; //则x的二进制值为1111 1111，y的值应为1111 1111 1111 1111 1111 1111 1000 1001；byte =1; short y=x; //则y的值应为0000 0000 0000 0000 0000 0000 0000 0001； 零扩展进行零扩展，即用零来填充长数据类型的高字节位 12unsigned char x=1000 1001b; short y=x; //则y的值应为00000000 10001001b；unsigned char x=0000 1001b; short y=x; //则y的值应为00000000 00001001b； △ 从较窄整型转换成较宽整型规定：如果最初的数值类型是有符号的，就进行符号扩展；如果它是char，那么不管它转化成什么类型，都是进行零扩展 12345678char c = (char)(0xff &amp; b);/* 0000 0000 0000 0000 0000 0000 1111 1111 (0Xff) &amp; 1111 1111 1111 1111 1111 1111 1001 1100 (b=-100) ----------------------------------------- 0000 0000 0000 0000 0000 0000 1001 1100 (100)*///0xff是第八位全部置1；其他位全部置0；//上面是不进行符号扩展]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Maven 学习笔记（二）]]></title>
      <url>%2F2017%2F03%2F11%2FMaven%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-2%2F</url>
      <content type="text"><![CDATA[Maven Dependency，Maven 除了快速构建项目外，还有一大功能就是管理项目依赖。Maven 的依赖管理通过groupId、artifactId、version等标识确定一个依赖的坐标，从而通过 Maven 仓库或获取对应的项目依赖的 Jar，自动化的解析任何一个 Java 构件。 Maven 坐标 groupId: 定义当前Maven项目隶属的实际项目. artifactId: 定义实际项目中的一个Maven项目(模块). version: 定义maven项目当前所处的版本. packaging: 定义Maven项目的打包方式. classifier: 定义构建输出的一些附属构件. 例如:一个项目的主构件是xxx-xxx-7.0.0.jar, 可能还需要javadoc和source, 这时javadoc和source就是附属构件的classifier, classifier不能定义, 它不是默认生成的, 而是由附加插件帮助生成的. groupId, artifactId, version是必须的, packaging 是可选的(默认jar), 而classifier是不能自定义的. maven项目生成的文件名一般为 artifactId-version[-classifier].packaging 依赖 POM 定义123456789101112131415161718192021222324&lt;project&gt;... &lt;!-- 项目所有的依赖--&gt; &lt;dependencies&gt; &lt;!-- 定义一个模块使用的一个依赖--&gt; &lt;dependency&gt; &lt;!-- 依赖的基本坐标--&gt; &lt;groupId&gt;&lt;/groupId&gt; &lt;artifactId&gt;&lt;artifactId&gt; &lt;version&gt;&lt;/version&gt; &lt;!-- 依赖类型,对应项目目标定义中的packaging, 不声明默认为Jar --&gt; &lt;type&gt;&lt;/type&gt; &lt;!-- 依赖作用范围--&gt; &lt;scope&gt;&lt;/scope&gt; &lt;!-- 标记依赖是否可选--&gt; &lt;optional&gt;&lt;/optional&gt; &lt;!-- 需要排除的依赖 --&gt; &lt;exclusions&gt; &lt;exclusion&gt;&lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;/dependencies&gt;...&lt;/project&gt; 依赖范围ScopeMaven会使用3种classpath来控制使用的依赖(编译classpath, 测试classpath, 运行测试classpath).Maven有以下几种依赖范围. compile 编译依赖范围. 默认依赖范围, 对应编译, 测试, 运行三种classpath都有效. eg: Spring-core test 测试依赖范围. 只对测试classpath有效, 在编译主代码或者运行项目中无法使用该依赖. eg: JUint provided 已提供的依赖范围. 对于编译和测试时有效, 运行时无效使用. eg: servlet-api runtime 运行时依赖范围. 对应测试和运行时有效, 但项目编译时无效. eg: JDBC ,编译时使用JDK提供的JDBC接口. system 系统依赖范围. 依赖范围和provided完全一致, 但是需要显示的指定依赖文件路径. 此类不是由Maven仓库解析处理,往往与本机系统绑定 1234567&lt;dependency&gt; &lt;groupId&gt;&lt;/groupId&gt; &lt;artifactId&gt;&lt;artifactId&gt; &lt;version&gt;&lt;/version&gt; &lt;scope&gt;system&lt;/scope&gt; &lt;systemPath&gt;$&#123;java.home&#125;/lib/rt.jar&lt;/systemPath&gt;&lt;/dependency&gt; import 导入依赖范围. 该依赖不会对classpath产生实际影响. Scope compile classpath test classpath runtime classpath compile Y Y Y test - Y - provided - Y Y runtime - Y Y system Y Y - 依赖传递依赖范围不但可以控制3种classpath的依赖,对传递性依赖也会产生影响. compile test provided runtime compile compile - - runtime test test - - test provided provided - provided provided runtime runtime - - runtime eg: Honks Test (Scope:Test, 对应表中行,第一依赖) 依赖Spring-email(Scope:compile, 对应表中列,第二依赖), Spring-email依赖java-mail. 则Honks Test通过传递依赖java-mail 依赖调解 依赖路径最近者优先 依赖路径相同, 先声明的优先 eg: A -&gt; B -&gt; C -&gt; X(1.0), A -&gt; B -&gt; X(2.0), 优先使用 X(2.0) [路径更短] A -&gt; B -&gt; X(1.0), A -&gt; B -&gt; X(2.0), 优先使用 X(1.0) [先声明]]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Java Annotation]]></title>
      <url>%2F2017%2F02%2F27%2FJava_Annotation%2F</url>
      <content type="text"><![CDATA[Java Annotation是JDK5.0引入的一种注释机制。随着 Spring 引入了大量的注释类，相比 XML 配置，注释配置更受欢迎，有进一步流行的趋势。可以通过 自定义一些注释来很大程度上减少代码。深入学习注解，就必须能定义自己的注解，并使用注解，在定义自己的注解之前，就必须要了解Java提供的元注解和相关定义注解的语法。 定义 Annotaiion需要声明为@interface @Target规定注释一定要写在什么语句上面@Target(ElementType.对应类型) 12345678910111213TYPE: 类,接口或者Enum声明FIELD: 域(属性)声明METHOD: 方法声明PARAMETER: 参数申明CONSTRUCTOR: 构造方法声明LOCAL_VARIABLE: 局部变量声明ANNOTATION_TYPE: 注释类声明PACKAGE: 包声明Java 8 之前的版本中，只能允许在声明式前使用 Annotation(Annotaion可以在任何使用Type的地方)TYPE_PARAMETER: Type 的声明式前TYPE_USE: 所有使用 Type 的地方(如：泛型，类型转换等) @Retention 需要在什么级别保存该注释信息@Retention(RetentionPolicy.对应类型) SOURCE: 注释将被编译器丢弃,例如@Override,这种只起到标示的注释 CLASS: 注释在class中,但是会被VM丢弃 RUNTIME: 注释在class中,VM中也会存在 @Documented 将此注解包含在Javadoc中 使用注释12345678910@Target(ElementType.METHOD)@Retention(RetentionPolicy.RUNTIME)@Documentedpublic @interface ValueBind &#123; enum fieldType&#123; STRING,INT &#125; fieldType type(); String value();&#125; 使用的Bean对象123456789101112131415161718192021222324252627282930313233public class Student implements Serializable &#123; private String studentId; private int age; private String name; public String getStudentId() &#123; return studentId; &#125; @ValueBind(type = ValueBind.fieldType.STRING,value = "7777") public void setStudentId(String studentId) &#123; this.studentId = studentId; &#125; public int getAge() &#123; return age; &#125; @ValueBind(type = ValueBind.fieldType.INT,value = "21") public void setAge(int age) &#123; this.age = age; &#125; public String getName() &#123; return name; &#125; @ValueBind(type = ValueBind.fieldType.STRING,value = "wuyu") public void setName(String name) &#123; this.name = name; &#125;&#125; 测试12345678910111213141516171819202122232425262728 public static void main(String[] args) throws Exception &#123; Object c = Class.forName("Student").newInstance(); /** * getMethod*() 获取的是类的public method * including those declared by the class(自己) or interface(接口) and those inherited from superclasses and superinterfaces(父类,父接口) * getDeclaredMethod*() 只得到自身申明的所有方法, * 包括public, protected, default (package) access, and private methods, but excluding inherited methods * * 对应没有method返回一个length=0 Array */ Method[] methodArray = c.getClass().getDeclaredMethods(); for (Method method: methodArray) &#123; if(method.isAnnotationPresent(ValueBind.class))&#123; ValueBind annotation = method.getAnnotation(ValueBind.class); String type = String.valueOf(annotation.type()); String value = annotation.value(); if("INT".equals(type))&#123; method.invoke(c,new Integer(value)); &#125;else&#123; method.invoke(c,value); &#125; &#125; &#125; AnnotationDemo1 annotationStudent = (AnnotationDemo1) c; System.out.println("StudentId===="+annotationStudent.getStudentId()); System.out.println("StudentName===="+annotationStudent.getName()); System.out.println("StudentAge===="+annotationStudent.getAge());&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Java Puzzler（1-4）]]></title>
      <url>%2F2017%2F02%2F11%2FJavaPuzzler-1%2F</url>
      <content type="text"><![CDATA[1. 奇数性123public static boolen isOdd(int i)&#123; return i %2 ==1;&#125; 上面的method是错误的，会在1/4的时间里返回的是错误值 a % b = c中c的值取决于a；只要a为正，无论b取何值，若有余数，c一定为正，同理可知a为负，c一定为负值。correct method：123456public static boolen idOdd(int i)&#123; rutrun i%2 != 0;&#125;punlic static boolen idOdd(int i)&#123; retrun (i&amp;1)!=0;&#125; 2. 找零时刻12345public class change&#123; punlic static void main (String[] args)&#123; System.out.println(2.00-1.10); &#125;&#125; 以上不会输出 0.9，而是0.899999999999使用printf（&quot;%.2f%n&quot;2.00-1.00);但是使用的double。△ Double是在一个很广的值域上提供一个很好的相识值，并不是精确值。在需要精确答案是，建议是要避免是用float和double，对于货币计算，建议使用int和long，Bigdecimal一定要使用Bigdecimal（String）构造器，千万不要使用BIgdecimal（double），返回仍会是不精确的值。 3. 长整除1234567public class LongDivsion&#123; public static void main(String[] args)&#123; final long a=24*60*60*1000*1000; final long b=24*60*60*1000; System.out.println(a/b); &#125;&#125; 以上返回不会输出1000，而是5。因为24*60*60*1000*1000会溢出，它并不是一个Long型，而是先算出结果后在转换成Long型的a。 1234567public class LongDivsion&#123; public static void main(String[] args)&#123; final long a=24L*60*60*1000*1000; final long b=24L*60*60*1000; System.out.println(a/b); &#125;&#125; △当操作很大的数时一定要提防溢出 4. 弱智问题（还是被骗了）12345public class Elementary&#123; public static void main(String[] args)&#123; System.out.println(1234567l); &#125;&#125; 注意1234567l，是l不是1…..△在使用long类型字面常量中，一定要用大写的L，千万不要用小写的l 同理，要避免使用单个l字母的变量名]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Maven 学习笔记（一）]]></title>
      <url>%2F2017%2F01%2F31%2FMaven%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1%2F</url>
      <content type="text"><![CDATA[做的项目大部分都是用 Maven 构建的，一直没有系统的学习和整理 Maven 的知识。最近接手的一个项目，研究架构代码的时候，发现一个大牛们写的一个通过解析 PDM 生成对应数据的生成实体对象的一个 Maven 插件。研究的时候发现很多 Maven 知识还不甚了解，找了本 《Maven 实战》系统的学习和整理知识点一遍。 Maven IntroduceMaven 是一种构建工具,同时还是一个依赖管理工具和项目信息管理工具.它提供了中央仓库,能帮我们自动下载构件. Maven 文件目录 bin 该目录包含mvn运行的脚本,这些脚本用来配置Java命令,mvnDebug,主要是 Maven 运行时开启debug,调试 Maven 本身. m2.conf文件, classworlds的配置文件. boot 只有一个文件,plexus-classworlds-(version).jar. 一个类加载器. Maven使用它加载对应自己的类库 conf settings.xml, 全局定义Maven行为. lib Maven运行所需的Java类库. 存放的真正的Maven, 里面内置了很多Maven的超级POM. 设置HTTP代理12345678910111213141516171819&lt;settings&gt;&lt;proxies&gt; &lt;proxy&gt; &lt;id&gt;my-proxy&lt;/id&gt; &lt;!-- 是否激活该代理 --&gt; &lt;active&gt; false | true &lt;/active&gt; &lt;!-- 代理协议 --&gt; &lt;protocol&gt;http&lt;/protocol&gt; &lt;host&gt;&lt;/host&gt; &lt;port&gt;&lt;/port&gt; &lt;!-- &lt;username&gt;***&lt;/username&gt; &lt;password&gt;***&lt;/password&gt; 设置不需要代理的主机名, * 表示所有以google.com的域名不使用代理 &lt;nonProxyHosts&gt;*.google.com&lt;/nonProxxyHosts&gt; --&gt; &lt;/proxy&gt;&lt;proxies&gt;&lt;/settings&gt; Maven ABC 编写POM 12345678910111213&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;!-- 指定当前POM版本,Maven2 以及Maven3 默认为 4.0.0 --&gt; &lt;modelVersion&gt;4.0.0&lt;/modleVersion&gt; &lt;!-- groupId+artifaceId定义一个项目的基本坐标--&gt; &lt;groupId&gt;&lt;/groupId&gt; &lt;!-- 当前所属group中的Maven的唯一ID--&gt; &lt;artifactId&gt;&lt;artifactId&gt; &lt;!-- artifast项目的版本号 --&gt; &lt;version&gt;&lt;/version&gt; &lt;!-- --&gt; &lt;name&gt;&lt;/name&gt;&lt;/project&gt; 编写主代码主代码位于 src/main/java, Java类的包名需要跟POM中定义的groupId和artifactId相吻合,编译输出为target 编写测试代码测试代码位于 src/test/java Archetype生成项目骨架1mvn archetype:generate]]></content>
    </entry>

    
  
  
</search>
